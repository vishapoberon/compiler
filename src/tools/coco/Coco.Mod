(* Implementation restrictions
       3  too many nodes in graph (>1500)                         CRG.NewNode
       4  too many sets (ANY-symbols or SYNC symbols)     CRT.NewAnySet, 
                                                                               CRT.ComputeSyncSet
       6  too many symbols (>300)                                   CRT.NewSym
       7  too many character classes (>50)                        CRT.NewClass
       9  too many conditions in generated code (>100)        CRX.NewCondSet
       
   Trace output (ddt settings: ${digit})
    0  Prints states of automaton
    1  Prints start symbols and followers of nonterminals (also option /s)
    2  Prints the internal graph
    3  Trace of start symbol set computation
    4  Trace of follow set computation
    5  suppresses FORWARD declarations in parser (for multipass compilers)
    6  Prints the symbol list
    7  Prints a cross reference list  (also option /x)
    8  Write statistics
==========================================================================*)
MODULE Coco;

IMPORT Oberon, TextFrames, Texts, Viewers, CRS, CRP, CRT;

CONST minErrDist = 8;

VAR w: Texts.Writer; lastErrPos: LONGINT;


PROCEDURE Error (n: INTEGER; pos: LONGINT);
  
  PROCEDURE Msg (s: ARRAY OF CHAR);
  BEGIN Texts.WriteString(w, s)
  END Msg;
  
BEGIN
  INC(CRS.errors);
  IF pos < lastErrPos + minErrDist THEN lastErrPos := pos; RETURN END;
  lastErrPos := pos;
  Texts.WriteInt(w, pos, 3); Texts.WriteString(w, ": ");
  IF n < 200 THEN
    CASE n OF
  |  0: Msg("EOF expected")
  |  1: Msg("ident expected")
  |  2: Msg("string expected")
  |  3: Msg("badString expected")
  |  4: Msg("number expected")
  |  5: Msg("'COMPILER' expected")
  |  6: Msg("'IMPORT' expected")
  |  7: Msg("';' expected")
  |  8: Msg("'PRODUCTIONS' expected")
  |  9: Msg("'=' expected")
  | 10: Msg("'.' expected")
  | 11: Msg("'END' expected")
  | 12: Msg("'CHARACTERS' expected")
  | 13: Msg("'TOKENS' expected")
  | 14: Msg("'PRAGMAS' expected")
  | 15: Msg("'COMMENTS' expected")
  | 16: Msg("'FROM' expected")
  | 17: Msg("'TO' expected")
  | 18: Msg("'NESTED' expected")
  | 19: Msg("'IGNORE' expected")
  | 20: Msg("'CASE' expected")
  | 21: Msg("'+' expected")
  | 22: Msg("'-' expected")
  | 23: Msg("'CHR' expected")
  | 24: Msg("'(' expected")
  | 25: Msg("')' expected")
  | 26: Msg("'ANY' expected")
  | 27: Msg("'|' expected")
  | 28: Msg("'WEAK' expected")
  | 29: Msg("'[' expected")
  | 30: Msg("']' expected")
  | 31: Msg("'{' expected")
  | 32: Msg("'}' expected")
  | 33: Msg("'SYNC' expected")
  | 34: Msg("'CONTEXT' expected")
  | 35: Msg("'<' expected")
  | 36: Msg("'>' expected")
  | 37: Msg("'<.' expected")
  | 38: Msg("'.>' expected")
  | 39: Msg("'(.' expected")
  | 40: Msg("'.)' expected")
  | 41: Msg("??? expected")
  | 42: Msg("invalid TokenFactor")
  | 43: Msg("invalid Factor")
  | 44: Msg("invalid Factor")
  | 45: Msg("invalid Term")
  | 46: Msg("invalid Symbol")
  | 47: Msg("invalid SimSet")
  | 48: Msg("this symbol not expected in TokenDecl")
  | 49: Msg("invalid TokenDecl")
  | 50: Msg("invalid Attribs")
  | 51: Msg("invalid Declaration")
  | 52: Msg("invalid Declaration")
  | 53: Msg("invalid Declaration")
  | 54: Msg("this symbol not expected in CR")
  | 55: Msg("invalid CR")
    ELSE Texts.WriteString(w, "error "); Texts.WriteInt(w, n, 0)
    END
  ELSE
    CASE n OF
    |  201: Msg("unexpected end of file");
    |  202: Msg("string terminator not on this line");
    |  203: Msg("a literal must not have attributes");
    |  204: Msg("this symbol kind not allowed in production");
    |  205: Msg("symbol declared without attributes");
    |  206: Msg("symbol declared with attributes");
    |  207: Msg("name declared twice");
    |  208: Msg("this type not allowed on left side of production");
    |  209: Msg("symbol earlier referenced without attributes");
    | 210: Msg("symbol earlier referenced with attributes");
    | 211: Msg("missing production for grammar name");
    | 212: Msg("grammar symbol must not have attributes");
    | 213: Msg("a literal must not be declared with a structure")
    | 214: Msg("semantic action not allowed here")
    | 215: Msg("undefined name")
    | 216: Msg("attributes not allowed in token declaration")
    | 217: Msg("name does not match name in heading")
    | 218: Msg("bad string in semantic action")
    | 219: Msg("Missing end of previous semantic action")
    | 220: Msg("token may be empty")
    | 221: Msg("token must not start with an iteration")
    | 222: Msg("only characters allowed in comment declaration")
    | 223: Msg("only terminals may be weak")
    | 224: Msg("tokens must not contain blanks")
    | 225: Msg("comment delimiter must not exceed 2 characters")
    | 226: Msg("character set contains more than one character")
    ELSE Texts.WriteString(w, "error "); Texts.WriteInt(w, n, 0)
    END
  END;
Texts.WriteLn(w); Texts.Append(Oberon.Log, w.buf)
END Error;

PROCEDURE Options(VAR s: Texts.Scanner);
  VAR i: INTEGER;
BEGIN
  IF s.nextCh = "\" THEN Texts.Scan(s); Texts.Scan(s);
    IF s.class = Texts.Name THEN i := 0;
      WHILE s.s[i] # 0X DO
        IF CAP(s.s[i]) = "X" THEN CRT.ddt[7] := TRUE
        ELSIF CAP(s.s[i]) = "S" THEN CRT.ddt[1] := TRUE
        END;
        INC(i)
      END
    END
  END;
END Options;


PROCEDURE Compile*;
  VAR v: Viewers.Viewer; f: TextFrames.Frame; s: Texts.Scanner; src, t: Texts.Text;
    pos, beg, end, time: LONGINT; i: INTEGER;
BEGIN
  Texts.OpenScanner(s, Oberon.Par.text, Oberon.Par.pos); Texts.Scan(s);
  f := Oberon.Par.frame(TextFrames.Frame);
  src := NIL; pos := 0;
  IF (s.class = Texts.Char) & (s.c = "^") THEN
    Oberon.GetSelection(t, beg, end, time);
    IF time >= 0 THEN Texts.OpenScanner(s, t, beg); Texts.Scan(s) END
  END;
  IF s.class = Texts.Name THEN
    NEW(src); Texts.Open(src, s.s);
  ELSIF (s.class = Texts.Char) & (s.c = "*") THEN
    v := Oberon.MarkedViewer();
    IF (v # NIL) & (v.dsc.next IS TextFrames.Frame) THEN
      src := v.dsc.next(TextFrames.Frame).text;
      Texts.OpenScanner(s, v.dsc(TextFrames.Frame).text, 0); Texts.Scan(s)
    END
  ELSIF (s.class = Texts.Char) & (s.c = "@") THEN
    Oberon.GetSelection(t, beg, end, time);
    IF time >= 0 THEN src := t; pos := beg; s.s := " " END
  END;
  IF src # NIL THEN
    Texts.WriteString (w, "Coco/R - Compiler-Compiler V2.2"); Texts.Append(Oberon.Log, w.buf);
    i := 0; WHILE i < 10 DO CRT.ddt[i] := FALSE; INC(i) END;
    Options(s);
    Texts.WriteLn(w); Texts.WriteString(w, s.s); Texts.Append(Oberon.Log, w.buf);
    CRS.Reset(src, pos, Error); lastErrPos := -10;
    CRP.Parse
  END
END Compile;

BEGIN
  Texts.OpenWriter(w)
END Coco.

