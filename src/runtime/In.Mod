MODULE In;

IMPORT Platform, SYSTEM, Reals, Out;

VAR
  Done-:     BOOLEAN;
  nextch:    CHAR;      (* Maintains 1 character read ahaead except at end of line. *)
  readstate: INTEGER;

CONST
  pending = 0;  (* readstate when at start of input or end of line. Implies nextch undefined. *)
  ready   = 1;  (* readstate when nextch is defined and contains next character on current line. *)
  eof     = 2;  (* readstate when at end of file. *)

PROCEDURE Open*;
VAR error: Platform.ErrorCode;
BEGIN
  error     := Platform.Seek(Platform.StdIn, 0, Platform.SeekSet); (* Rewind STDIN to beginning of file. *)
  readstate := pending;
  Done      := TRUE;
END Open;

PROCEDURE ReadChar;
VAR error: Platform.ErrorCode; n: LONGINT;
BEGIN
  error := Platform.ReadBuf(Platform.StdIn, nextch, n);
  IF (error = 0) & (n = 1) THEN readstate := ready ELSE readstate := eof END
END ReadChar;

PROCEDURE StartRead;  (* Ensure either nextch is valid or we're at EOF. *)
BEGIN Out.Flush; IF readstate = pending THEN ReadChar END;
END StartRead;

PROCEDURE StartAndSkip; (* Like StartRead, but also skip over blanks, CR, LF, tab. *)
BEGIN StartRead;
  WHILE (readstate = ready) & (nextch <= " ") DO ReadChar END
END StartAndSkip;

PROCEDURE Char*(VAR ch: CHAR);
BEGIN
  StartRead;
  Done := readstate = ready;
  IF Done THEN
    ch := nextch;
    IF ch = 0AX THEN readstate := pending ELSE ReadChar END
  ELSE
    ch := 0X
  END
END Char;

PROCEDURE HugeInt*(VAR h: HUGEINT);
VAR
  neg, hex, endofnum: BOOLEAN;
  decacc, hexacc, digit: HUGEINT;
BEGIN
  StartAndSkip;
  Done := FALSE;
  IF readstate = ready THEN
    neg      := nextch = '-'; IF neg THEN ReadChar END;
    hex      := FALSE;
    endofnum := FALSE;
    decacc   := 0;
    hexacc   := 0;
    WHILE (readstate = ready) & ~endofnum DO
      digit := -1;
      IF (nextch >= "0") & (nextch <= "9") THEN
        digit := ORD(nextch) MOD 16
      ELSIF (nextch >= "a") & (nextch <= "f")
         OR (nextch >= "A") & (nextch <= "F") THEN
        digit := ORD(nextch) MOD 16 + 9; hex := TRUE
      END;
      IF digit >= 0 THEN
        Done   := TRUE;
        decacc := decacc * 10 + digit;
        hexacc := hexacc * 16 + digit;
        ReadChar
      ELSIF nextch = "H" THEN
        hex := TRUE; endofnum := TRUE; ReadChar
      ELSE
        endofnum := TRUE
      END
    END;
    IF Done THEN
      IF hex THEN h := hexacc ELSE h := decacc END;
      IF neg THEN h := -h END
    ELSE
      h := 0
    END
  END
END HugeInt;

PROCEDURE Int*(VAR i: INTEGER);
VAR h: HUGEINT;
BEGIN HugeInt(h); i := SYSTEM.VAL(INTEGER, h)
END Int;

PROCEDURE LongInt*(VAR i: LONGINT);
VAR h: HUGEINT;
BEGIN HugeInt(h); i := SYSTEM.VAL(LONGINT, h)
END LongInt;

PROCEDURE Line*(VAR line: ARRAY OF CHAR);
VAR i: INTEGER;
BEGIN StartRead; i := 0; Done := readstate = ready;
  WHILE (readstate = ready) & (nextch # 0DX) & (nextch # 0AX) & (i < LEN(line)-1) DO
    line[i] := nextch; INC(i); ReadChar
  END;
  line[i] := 0X;
  IF (readstate = ready) & (nextch = 0DX) THEN ReadChar END;
  IF (readstate = ready) & (nextch = 0AX) THEN readstate := pending END;
END Line;

PROCEDURE String*(VAR str: ARRAY OF CHAR);
VAR i: INTEGER;
BEGIN StartAndSkip; i := 0;
  IF (readstate = ready) & (nextch = '"') THEN                         (* " *)
    ReadChar;
    WHILE (readstate = ready)
        & (i < LEN(str)-1)
        & (nextch >= " ")
        & (nextch # '"') DO                                            (* " *)
      str[i] := nextch; ReadChar; INC(i)
    END
  END;
  Done := (readstate = ready)
        & (i < LEN(str)-1)
        & (nextch = '"');                                              (* " *)
  IF Done THEN
    ReadChar; str[i] := 0X
  ELSE
    str[0] := 0X
  END
END String;

PROCEDURE Name*(VAR name: ARRAY OF CHAR); (* Read filename. Presumably using shell semantics. *)
BEGIN HALT(99) (* Not implemented *)
END Name;

PROCEDURE StrToReal(s: ARRAY OF CHAR; VAR r: REAL);
VAR p, e: INTEGER; y, g: REAL; neg, negE: BOOLEAN;
BEGIN
	p := 0;
	WHILE (s[p] = " ") OR (s[p] = "0") DO INC(p) END;
	IF s[p] = "-" THEN neg := TRUE; INC(p) ELSE neg := FALSE END;
	WHILE (s[p] = " ") OR (s[p] = "0") DO INC(p) END;
	
	y := 0;
	WHILE ("0" <= s[p]) & (s[p] <= "9") DO
		y := y * 10 + (ORD(s[p]) - 30H);
		INC(p);
	END;
	IF s[p] = "." THEN
		INC(p); g := 1; 
		WHILE ("0" <= s[p]) & (s[p] <= "9") DO
			g := g / 10; y := y + g * (ORD(s[p]) - 30H);
			INC(p);
		END;
	END;
	IF (s[p] = "D") OR (s[p] = "E") THEN
		INC(p); e := 0;
		IF s[p] = "-" THEN negE := TRUE; INC(p) ELSE negE := FALSE END;
		WHILE (s[p] = "0") DO INC(p) END;
		WHILE ("0" <= s[p]) & (s[p] <= "9") DO
			e := e * 10 + (ORD(s[p]) - 30H);
			INC(p);
		END;
		IF negE THEN y := y / Reals.Ten(e)
		ELSE y := y * Reals.Ten(e) END;
	END;
	IF neg THEN y := -y END;
	r := y;
END StrToReal;

PROCEDURE StrToLongReal(s: ARRAY OF CHAR; VAR r: LONGREAL);
VAR p, e: INTEGER; y, g: LONGREAL; neg, negE: BOOLEAN;
BEGIN
	p := 0;
	WHILE (s[p] = " ") OR (s[p] = "0") DO INC(p) END;
	IF s[p] = "-" THEN neg := TRUE; INC(p) ELSE neg := FALSE END;
	WHILE (s[p] = " ") OR (s[p] = "0") DO INC(p) END;
	
	y := 0;
	WHILE ("0" <= s[p]) & (s[p] <= "9") DO
		y := y * 10 + (ORD(s[p]) - 30H);
		INC(p);
	END;
	IF s[p] = "." THEN
		INC(p); g := 1; 
		WHILE ("0" <= s[p]) & (s[p] <= "9") DO
			g := g / 10; y := y + g * (ORD(s[p]) - 30H);
			INC(p);
		END;
	END;
	IF (s[p] = "D") OR (s[p] = "E") THEN
		INC(p); e := 0;
		IF s[p] = "-" THEN negE := TRUE; INC(p) ELSE negE := FALSE END;
		WHILE (s[p] = "0") DO INC(p) END;
		WHILE ("0" <= s[p]) & (s[p] <= "9") DO
			e := e * 10 + (ORD(s[p]) - 30H);
			INC(p);
		END;
		IF negE THEN y := y / Reals.Ten(e)
		ELSE y := y * Reals.Ten(e) END;
	END;
	IF neg THEN y := -y END;
	r := y;
END StrToLongReal;

PROCEDURE Real*(VAR x: REAL);
VAR
  str: ARRAY 16 OF CHAR;
BEGIN
  Line(str);
  StrToReal(str, x);
END Real;

PROCEDURE LongReal*(VAR y: LONGREAL);
VAR
  str: ARRAY 16 OF CHAR;
BEGIN
  Line(str);
  StrToLongReal(str, y);
END LongReal;



BEGIN
  nextch    := 0X;
  readstate := pending;
  Done      := TRUE;
END In.
